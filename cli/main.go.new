// Just the initWebRTC function modification to fix handler setup

// initWebRTC initializes the WebRTC components
func (c *Client) initWebRTC(peerToken string, isInitiator bool) {
    c.logMessage("Initializing WebRTC components (isInitiator: %v)", isInitiator)

    // Store the peer token in the connection state
    c.logMessage("Setting peer token: '%s'", peerToken)

    // Create WebRTC connection
    c.logMessage("Creating WebRTC connection")
    c.webrtcConn = &ClientWebRTCConnection{
        Connection: ourwebrtc.NewConnection(
            c.ui,
            func() {
                c.logMessage("Connection setup callback called")
                c.ui.ShowConnectionAccepted("")
            },
            func() {
                c.logMessage("Channels ready callback called")

                // Make sure the channels are initialized
                if c.webrtcConn.Connection.GetControlChannel() == nil || c.webrtcConn.Connection.GetDataChannel() == nil {
                    c.logMessage("Cannot set up channel handlers: channels not initialized")
                    return
                }

                // Log channel states
                controlState := c.webrtcConn.Connection.GetControlChannel().ReadyState()
                dataState := c.webrtcConn.Connection.GetDataChannel().ReadyState()
                c.logMessage("Control channel state: %s", controlState.String())
                c.logMessage("Data channel state: %s", dataState.String())

                // Make sure the channels are in the open state
                if controlState != pionwebrtc.DataChannelStateOpen ||
                    dataState != pionwebrtc.DataChannelStateOpen {
                    c.logMessage("Cannot set up channel handlers: channels not in open state")
                    return
                }

                // Create receiver first (needed for message handlers)
                c.receiver = transfer.NewReceiver(
                    c.webrtcConn.Connection.GetControlChannel(),
                    c.webrtcConn.Connection.GetDataChannel(),
                    c.ui,
                    func(status string, direction string) {
                        c.ui.UpdateTransferProgress(status, direction)
                    },
                    fixedChunkSize,
                )

                // Create sender
                c.sender = transfer.NewSender(
                    c.webrtcConn.Connection.GetControlChannel(),
                    c.webrtcConn.Connection.GetDataChannel(),
                    c.ui,
                    func(status string, direction string) {
                        c.ui.UpdateTransferProgress(status, direction)
                    },
                    fixedChunkSize,
                    maxWebRTCMessageSize,
                )

                // Set up message handlers in the connection before creating channels
                c.logMessage("Setting up message handlers")
                c.webrtcConn.Connection.SetMessageHandlers(
                    // Control channel handler
                    func(msg []byte) {
                        c.logMessage(fmt.Sprintf("Received control message: %s", string(msg)))
                        if err := c.receiver.HandleControlMessage(msg); err != nil {
                            c.logMessage(fmt.Sprintf("Error handling control message: %v", err))
                        }
                    },
                    // Data channel handler
                    func(msg []byte) {
                        c.logMessage(fmt.Sprintf("Received data message of size: %d bytes", len(msg)))
                        if err := c.receiver.HandleDataChunk(msg); err != nil {
                            c.logMessage(fmt.Sprintf("Error handling data chunk: %v", err))
                        }
                    },
                )

                // Create WebRTC channels after handlers are set
                c.logMessage("Creating WebRTC channels")
                c.webrtcChannels = ourwebrtc.NewChannels(
                    c.webrtcConn.Connection,
                    c.ui,
                    c.receiver,
                    c.receiver,
                )

                c.logMessage("WebRTC channels created successfully")

                // Set up channel handlers
                c.logMessage("Setting up channel handlers")
                c.webrtcChannels.SetupChannelHandlers()
                c.logMessage("Channel handlers setup completed")

                // Log that channels are ready
                c.logMessage("Channels are ready, handlers set up")

                // Verify components
                if c.sender == nil || c.receiver == nil || c.webrtcChannels == nil {
                    c.logMessage("WARNING: One or more components not initialized properly")
                } else {
                    c.logMessage("All components initialized successfully")
                }
            },
            fixedChunkSize,
            maxWebRTCMessageSize,
        ),
        client: c,
    }

    // Set the peer token in the connection state
    c.webrtcConn.Connection.SetPeerToken(peerToken)

    // Create WebRTC signaling
    c.webrtcSignaling = ourwebrtc.NewSignaling(
        c.webrtcConn.Connection,
        c,
        c.ui,
    )

    // Set up WebRTC connection
    err := c.webrtcConn.Connection.SetupPeerConnection()
    if err != nil {
        c.ui.ShowError(fmt.Sprintf("Failed to setup peer connection: %v", err))
        return
    }

    // Set up WebRTC signaling
    c.webrtcSignaling.SetupICEHandlers()

    // If we're the initiator, we'll wait for the "accepted" message before creating an offer
    if isInitiator {
        c.logMessage("Waiting for accepted message before creating offer")
    }
}
